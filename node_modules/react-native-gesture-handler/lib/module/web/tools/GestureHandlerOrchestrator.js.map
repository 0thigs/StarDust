{"version":3,"sources":["GestureHandlerOrchestrator.ts"],"names":["State","PointerType","PointerTracker","isPointerInBounds","GestureHandlerOrchestrator","constructor","scheduleFinishedHandlersCleanup","handlingChangeSemaphore","cleanupFinishedHandlers","cleanHandler","handler","reset","setActive","setAwaiting","setActivationIndex","Number","MAX_VALUE","removeHandlerFromOrchestrator","gestureHandlers","splice","indexOf","awaitingHandlers","handlersToCancel","i","length","isFinished","getState","isAwaiting","hasOtherHandlerToWaitFor","hasToWait","forEach","otherHandler","shouldHandlerWaitForOther","tryActivate","addAwaitingHandler","CANCELLED","FAILED","shouldActivate","makeActive","ACTIVE","fail","BEGAN","cancel","shouldHandlerBeCancelledBy","cleanupAwaitingHandlers","onHandlerStateChange","newState","oldState","sendIfDisabled","isEnabled","END","sendEvent","isActive","UNDETERMINED","currentState","setShouldResetProgress","activationIndex","push","alreadyExists","recordHandlerIfNotPresent","MAX_SAFE_INTEGER","shouldWaitForHandlerFailure","shouldRequireToWaitForFailure","canRunSimultaneously","gh1","gh2","shouldRecognizeSimultaneously","shouldBeCancelledByOther","handlerPointers","getTrackedPointersID","otherPointers","shareCommonPointers","getView","checkOverlap","overlap","pointer","handlerX","getTracker","getLastX","handlerY","getLastY","x","y","otherX","otherY","state","cancelMouseAndPenGestures","currentHandler","getPointerType","MOUSE","PEN","resetTracker","getInstance","instance"],"mappings":"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","sourcesContent":["import { State } from '../../State';\nimport { PointerType } from '../interfaces';\n\nimport GestureHandler from '../handlers/GestureHandler';\nimport PointerTracker from './PointerTracker';\nimport { isPointerInBounds } from '../utils';\n\nexport default class GestureHandlerOrchestrator {\n  private static instance: GestureHandlerOrchestrator;\n\n  private gestureHandlers: GestureHandler[] = [];\n  private awaitingHandlers: GestureHandler[] = [];\n  private handlersToCancel: GestureHandler[] = [];\n\n  private handlingChangeSemaphore = 0;\n  private activationIndex = 0;\n\n  // Private beacuse of Singleton\n  // eslint-disable-next-line no-useless-constructor, @typescript-eslint/no-empty-function\n  private constructor() {}\n\n  private scheduleFinishedHandlersCleanup(): void {\n    if (this.handlingChangeSemaphore === 0) {\n      this.cleanupFinishedHandlers();\n    }\n  }\n\n  private cleanHandler(handler: GestureHandler): void {\n    handler.reset();\n    handler.setActive(false);\n    handler.setAwaiting(false);\n    handler.setActivationIndex(Number.MAX_VALUE);\n  }\n\n  public removeHandlerFromOrchestrator(handler: GestureHandler): void {\n    this.gestureHandlers.splice(this.gestureHandlers.indexOf(handler), 1);\n    this.awaitingHandlers.splice(this.awaitingHandlers.indexOf(handler), 1);\n    this.handlersToCancel.splice(this.handlersToCancel.indexOf(handler), 1);\n  }\n\n  private cleanupFinishedHandlers(): void {\n    for (let i = this.gestureHandlers.length - 1; i >= 0; --i) {\n      const handler = this.gestureHandlers[i];\n\n      if (!handler) {\n        continue;\n      }\n      if (this.isFinished(handler.getState()) && !handler.isAwaiting()) {\n        this.gestureHandlers.splice(i, 1);\n\n        this.cleanHandler(handler);\n      }\n    }\n  }\n\n  private hasOtherHandlerToWaitFor(handler: GestureHandler): boolean {\n    let hasToWait = false;\n    this.gestureHandlers.forEach((otherHandler) => {\n      if (\n        otherHandler &&\n        !this.isFinished(otherHandler.getState()) &&\n        this.shouldHandlerWaitForOther(handler, otherHandler)\n      ) {\n        hasToWait = true;\n        return;\n      }\n    });\n\n    return hasToWait;\n  }\n\n  private tryActivate(handler: GestureHandler): void {\n    if (this.hasOtherHandlerToWaitFor(handler)) {\n      this.addAwaitingHandler(handler);\n    } else if (\n      handler.getState() !== State.CANCELLED &&\n      handler.getState() !== State.FAILED\n    ) {\n      if (this.shouldActivate(handler)) {\n        this.makeActive(handler);\n      } else {\n        switch (handler.getState()) {\n          case State.ACTIVE:\n            handler.fail();\n            break;\n          case State.BEGAN:\n            handler.cancel();\n        }\n      }\n    }\n  }\n\n  private shouldActivate(handler: GestureHandler): boolean {\n    for (const otherHandler of this.gestureHandlers) {\n      if (this.shouldHandlerBeCancelledBy(handler, otherHandler)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private cleanupAwaitingHandlers(handler: GestureHandler): void {\n    for (let i = 0; i < this.awaitingHandlers.length; ++i) {\n      if (\n        !this.awaitingHandlers[i].isAwaiting() &&\n        this.shouldHandlerWaitForOther(this.awaitingHandlers[i], handler)\n      ) {\n        this.cleanHandler(this.awaitingHandlers[i]);\n        this.awaitingHandlers.splice(i, 1);\n      }\n    }\n  }\n\n  public onHandlerStateChange(\n    handler: GestureHandler,\n    newState: State,\n    oldState: State,\n    sendIfDisabled?: boolean\n  ): void {\n    if (!handler.isEnabled() && !sendIfDisabled) {\n      return;\n    }\n\n    this.handlingChangeSemaphore += 1;\n\n    if (this.isFinished(newState)) {\n      this.awaitingHandlers.forEach((otherHandler) => {\n        if (this.shouldHandlerWaitForOther(otherHandler, handler)) {\n          if (newState === State.END) {\n            otherHandler?.cancel();\n            if (otherHandler.getState() === State.END) {\n              // Handle edge case, where discrete gestures end immediately after activation thus\n              // their state is set to END and when the gesture they are waiting for activates they\n              // should be cancelled, however `cancel` was never sent as gestures were already in the END state.\n              // Send synthetic BEGAN -> CANCELLED to properly handle JS logic\n              otherHandler.sendEvent(State.CANCELLED, State.BEGAN);\n            }\n            otherHandler?.setAwaiting(false);\n          } else {\n            this.tryActivate(otherHandler);\n          }\n        }\n      });\n    }\n\n    if (newState === State.ACTIVE) {\n      this.tryActivate(handler);\n    } else if (oldState === State.ACTIVE || oldState === State.END) {\n      if (handler.isActive()) {\n        handler.sendEvent(newState, oldState);\n      } else if (\n        oldState === State.ACTIVE &&\n        (newState === State.CANCELLED || newState === State.FAILED)\n      ) {\n        handler.sendEvent(newState, State.BEGAN);\n      }\n    } else if (\n      oldState !== State.UNDETERMINED ||\n      newState !== State.CANCELLED\n    ) {\n      handler.sendEvent(newState, oldState);\n    }\n\n    this.handlingChangeSemaphore -= 1;\n\n    this.scheduleFinishedHandlersCleanup();\n\n    if (this.awaitingHandlers.indexOf(handler) < 0) {\n      this.cleanupAwaitingHandlers(handler);\n    }\n  }\n\n  private makeActive(handler: GestureHandler): void {\n    const currentState = handler.getState();\n\n    handler.setActive(true);\n    handler.setShouldResetProgress(true);\n    handler.setActivationIndex(this.activationIndex++);\n\n    this.gestureHandlers.forEach((otherHandler) => {\n      // Order of arguments is correct - we check whether current handler should cancel existing handlers\n\n      if (this.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n        this.handlersToCancel.push(otherHandler);\n      }\n    });\n\n    for (let i = this.handlersToCancel.length - 1; i >= 0; --i) {\n      this.handlersToCancel[i]?.cancel();\n    }\n    this.awaitingHandlers.forEach((otherHandler) => {\n      if (this.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n        otherHandler?.cancel();\n        otherHandler?.setAwaiting(true);\n      }\n    });\n\n    handler.sendEvent(State.ACTIVE, State.BEGAN);\n\n    if (currentState !== State.ACTIVE) {\n      handler.sendEvent(State.END, State.ACTIVE);\n      if (currentState !== State.END) {\n        handler.sendEvent(State.UNDETERMINED, State.END);\n      }\n    }\n\n    if (handler.isAwaiting()) {\n      handler.setAwaiting(false);\n      for (let i = 0; i < this.awaitingHandlers.length; ++i) {\n        if (this.awaitingHandlers[i] === handler) {\n          this.awaitingHandlers.splice(i, 1);\n        }\n      }\n    }\n\n    this.handlersToCancel = [];\n  }\n\n  private addAwaitingHandler(handler: GestureHandler): void {\n    let alreadyExists = false;\n\n    this.awaitingHandlers.forEach((otherHandler) => {\n      if (otherHandler === handler) {\n        alreadyExists = true;\n        return;\n      }\n    });\n\n    if (alreadyExists) {\n      return;\n    }\n\n    this.awaitingHandlers.push(handler);\n\n    handler.setAwaiting(true);\n    handler.setActivationIndex(this.activationIndex++);\n  }\n\n  public recordHandlerIfNotPresent(handler: GestureHandler): void {\n    let alreadyExists = false;\n\n    this.gestureHandlers.forEach((otherHandler) => {\n      if (otherHandler === handler) {\n        alreadyExists = true;\n        return;\n      }\n    });\n\n    if (alreadyExists) {\n      return;\n    }\n\n    this.gestureHandlers.push(handler);\n\n    handler.setActive(false);\n    handler.setAwaiting(false);\n    handler.setActivationIndex(Number.MAX_SAFE_INTEGER);\n  }\n\n  private shouldHandlerWaitForOther(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    return (\n      handler !== otherHandler &&\n      (handler.shouldWaitForHandlerFailure(otherHandler) ||\n        otherHandler.shouldRequireToWaitForFailure(handler))\n    );\n  }\n\n  private canRunSimultaneously(\n    gh1: GestureHandler,\n    gh2: GestureHandler\n  ): boolean {\n    return (\n      gh1 === gh2 ||\n      gh1.shouldRecognizeSimultaneously(gh2) ||\n      gh2.shouldRecognizeSimultaneously(gh1)\n    );\n  }\n\n  private shouldHandlerBeCancelledBy(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    if (this.canRunSimultaneously(handler, otherHandler)) {\n      return false;\n    }\n\n    if (\n      handler !== otherHandler &&\n      (handler.isAwaiting() || handler.getState() === State.ACTIVE)\n    ) {\n      // For now it always returns false\n      return handler.shouldBeCancelledByOther(otherHandler);\n    }\n\n    const handlerPointers: number[] = handler.getTrackedPointersID();\n    const otherPointers: number[] = otherHandler.getTrackedPointersID();\n\n    if (\n      !PointerTracker.shareCommonPointers(handlerPointers, otherPointers) &&\n      handler.getView() !== otherHandler.getView()\n    ) {\n      return this.checkOverlap(handler, otherHandler);\n    }\n\n    return true;\n  }\n\n  private checkOverlap(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    // If handlers don't have common pointers, default return value is false.\n    // However, if at least on pointer overlaps with both handlers, we return true\n    // This solves issue in overlapping parents example\n\n    // TODO: Find better way to handle that issue, for example by activation order and handler cancelling\n\n    const handlerPointers: number[] = handler.getTrackedPointersID();\n    const otherPointers: number[] = otherHandler.getTrackedPointersID();\n\n    let overlap = false;\n\n    handlerPointers.forEach((pointer: number) => {\n      const handlerX: number = handler.getTracker().getLastX(pointer);\n      const handlerY: number = handler.getTracker().getLastY(pointer);\n\n      if (\n        isPointerInBounds(handler.getView(), { x: handlerX, y: handlerY }) &&\n        isPointerInBounds(otherHandler.getView(), { x: handlerX, y: handlerY })\n      ) {\n        overlap = true;\n      }\n    });\n\n    otherPointers.forEach((pointer: number) => {\n      const otherX: number = otherHandler.getTracker().getLastX(pointer);\n      const otherY: number = otherHandler.getTracker().getLastY(pointer);\n\n      if (\n        isPointerInBounds(handler.getView(), { x: otherX, y: otherY }) &&\n        isPointerInBounds(otherHandler.getView(), { x: otherX, y: otherY })\n      ) {\n        overlap = true;\n      }\n    });\n\n    return overlap;\n  }\n\n  private isFinished(state: State): boolean {\n    return (\n      state === State.END || state === State.FAILED || state === State.CANCELLED\n    );\n  }\n\n  // This function is called when handler receives touchdown event\n  // If handler is using mouse or pen as a pointer and any handler receives touch event,\n  // mouse/pen event dissappears - it doesn't send onPointerCancel nor onPointerUp (and others)\n  // This became a problem because handler was left at active state without any signal to end or fail\n  // To handle this, when new touch event is received, we loop through active handlers and check which type of\n  // pointer they're using. If there are any handler with mouse/pen as a pointer, we cancel them\n  public cancelMouseAndPenGestures(currentHandler: GestureHandler): void {\n    this.gestureHandlers.forEach((handler: GestureHandler) => {\n      if (\n        handler.getPointerType() !== PointerType.MOUSE &&\n        handler.getPointerType() !== PointerType.PEN\n      ) {\n        return;\n      }\n\n      if (handler !== currentHandler) {\n        handler.cancel();\n      } else {\n        // Handler that received touch event should have its pointer tracker reset\n        // This allows handler to smoothly change from mouse/pen to touch\n        // The drawback is, that when we try to use mouse/pen one more time, it doesn't send onPointerDown at the first time\n        // so it is required to click two times to get handler to work\n        //\n        // However, handler will receive manually created onPointerEnter that is triggered in EventManager in onPointerMove method.\n        // There may be possibility to use that fact to make handler respond properly to first mouse click\n        handler.getTracker().resetTracker();\n      }\n    });\n  }\n\n  public static getInstance(): GestureHandlerOrchestrator {\n    if (!GestureHandlerOrchestrator.instance) {\n      GestureHandlerOrchestrator.instance = new GestureHandlerOrchestrator();\n    }\n\n    return GestureHandlerOrchestrator.instance;\n  }\n}\n"]}