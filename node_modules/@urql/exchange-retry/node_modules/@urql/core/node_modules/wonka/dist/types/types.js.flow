// @flow

// see https://gist.github.com/thecotne/6e5969f4aaf8f253985ed36b30ac9fe0
type $FlowGen$If<X: boolean, Then, Else = empty> = $Call<
  ((true, Then, Else) => Then) & ((false, Then, Else) => Else),
  X,
  Then,
  Else
>;

type $FlowGen$Assignable<A, B> = $Call<
  ((...r: [B]) => true) & ((...r: [A]) => false),
  A
>;

/**
 * A talkback signal is used to tell a [Source] that either the [Sink] is ready for new values or that the stream should be cancelled
 */

declare export var TalkbackKind: {|
  +Pull: 0, // 0
  +Close: 1, // 1
|};

/**
 * A talkback callback is sent to the sink with the [Start] signal to communicate signals back to the source.
 */
export type TalkbackFn = (signal: $Values<typeof TalkbackKind>) => void;
export type TeardownFn = () => void;
declare export var SignalKind: {|
  +Start: 0, // 0
  +Push: 1, // 1
  +End: 0, // 0
|};
export interface Tag<T> {
  tag: T;
}
/**
 * The start [Signal] is the first signal and carries a callback (talkback) so the sink can send signals to the source
 */
export type Start<_T> = { ...Tag<typeof SignalKind.Start>, ...[TalkbackFn] };
/**
 * The Push [Signal] carries new values to the sink, like in an event emitter
 */
export type Push<T> = { ...Tag<typeof SignalKind.Push>, ...[T] };
/**
 * A signal that communicates new events to a sink.
 */
export type Signal<T> = Start<T> | Push<T> | typeof SignalKind.End;
/**
 * A sink accepts new values from a [Source], like [Push], [Start], and an end signal. The [Start] is used to receive a callback to send talkback signals back to the source.
 */
export type Sink<T> = (signal: Signal<T>) => void;
/**
 * A source is a function that accepts a [Sink] and then starts sending [Signal]s to it.
 */
export type Source<T> = (sink: Sink<T>) => void;
/**
 * An operator transforms a [Source] and returns a new [Source], potentially with different timings or output types.
 */
export type Operator<In, Out> = (a: Source<In>) => Source<Out>;
/**
 * Extracts the type of a given Source
 */
export type TypeOfSource<T> = $FlowGen$If<
  $FlowGen$Assignable<T, Source<U>>,
  U,
  empty
>;
export interface Subscription {
  unsubscribe(): void;
}
export interface Observer<T> {
  next(value: T): void;
  complete(): void;
}
export type Subject<T> = {
  source: Source<T>,
  ...
} & Observer<T>;
