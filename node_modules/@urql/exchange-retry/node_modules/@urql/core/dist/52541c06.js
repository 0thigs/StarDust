var graphql = require('graphql');
var wonka = require('wonka');
var generateErrorMessage = (networkErr, graphQlErrs) => {
  var error = '';
  if (networkErr) return `[Network] ${networkErr.message}`;
  if (graphQlErrs) {
    for (var err of graphQlErrs) {
      if (error) error += '\n';
      error += `[GraphQL] ${err.message}`;
    }
  }
  return error;
};
var rehydrateGraphQlError = error => {
  if (typeof error === 'string') {
    return new graphql.GraphQLError(error);
  } else if (typeof error === 'object' && error.message) {
    return new graphql.GraphQLError(error.message, error.nodes, error.source, error.positions, error.path, error, error.extensions || {});
  } else {
    return error;
  }
};
/** An error which can consist of GraphQL errors and Network errors. */
class CombinedError extends Error {
  constructor(input) {
    var normalizedGraphQLErrors = (input.graphQLErrors || []).map(rehydrateGraphQlError);
    var message = generateErrorMessage(input.networkError, normalizedGraphQLErrors);
    super(message);
    this.name = 'CombinedError';
    this.message = message;
    this.graphQLErrors = normalizedGraphQLErrors;
    this.networkError = input.networkError;
    this.response = input.response;
  }
  toString() {
    return this.message;
  }
}

// When we have separate strings it's useful to run a progressive
// version of djb2 where we pretend that we're still looping over
// the same string
var phash = (x, seed) => {
  var h = typeof seed === 'number' ? seed | 0 : 5381;
  for (var i = 0, l = x.length | 0; i < l; i++) {
    h = (h << 5) + h + x.charCodeAt(i);
  }
  return h;
};
var seen = new Set();
var cache = new WeakMap();
var stringify = x => {
  if (x === null || seen.has(x)) {
    return 'null';
  } else if (typeof x !== 'object') {
    return JSON.stringify(x) || '';
  } else if (x.toJSON) {
    return stringify(x.toJSON());
  } else if (Array.isArray(x)) {
    var _out = '[';
    for (var value of x) {
      if (_out !== '[') _out += ',';
      value = stringify(value);
      _out += value.length > 0 ? value : 'null';
    }
    _out += ']';
    return _out;
  }
  var keys = Object.keys(x).sort();
  if (!keys.length && x.constructor && x.constructor !== Object) {
    var key = cache.get(x) || Math.random().toString(36).slice(2);
    cache.set(x, key);
    return `{"__key":"${key}"}`;
  }
  seen.add(x);
  var out = '{';
  for (var _key of keys) {
    var _value = stringify(x[_key]);
    if (_value) {
      if (out.length > 1) out += ',';
      out += stringify(_key) + ':' + _value;
    }
  }
  seen.delete(x);
  out += '}';
  return out;
};
var stringifyVariables = x => {
  seen.clear();
  return stringify(x);
};
var SOURCE_NAME = 'gql';
var GRAPHQL_STRING_RE = /("{3}[\s\S]*"{3}|"(?:\\.|[^"])*")/g;
var REPLACE_CHAR_RE = /(#[^\n\r]+)?(?:\n|\r\n?|$)+/g;
var replaceOutsideStrings = (str, idx) => idx % 2 === 0 ? str.replace(REPLACE_CHAR_RE, '\n') : str;
var sanitizeDocument = node => node.split(GRAPHQL_STRING_RE).map(replaceOutsideStrings).join('').trim();
var prints = new Map();
var docs = new Map();
var stringifyDocument = node => {
  var printed;
  if (typeof node === 'string') {
    printed = sanitizeDocument(node);
  } else if (node.loc && docs.get(node.__key) === node) {
    printed = node.loc.source.body;
  } else {
    printed = prints.get(node) || sanitizeDocument(graphql.print(node));
    prints.set(node, printed);
  }
  if (typeof node !== 'string' && !node.loc) {
    node.loc = {
      start: 0,
      end: printed.length,
      source: {
        body: printed,
        name: SOURCE_NAME,
        locationOffset: {
          line: 1,
          column: 1
        }
      }
    };
  }
  return printed;
};
var hashDocument = node => {
  var key = phash(stringifyDocument(node));
  // Add the operation name to the produced hash
  if (typeof node === 'object' && 'definitions' in node) {
    var operationName = getOperationName(node);
    if (operationName) key = phash(`\n# ${operationName}`, key);
  }
  return key;
};
var keyDocument = node => {
  var key;
  var query;
  if (typeof node === 'string') {
    key = hashDocument(node);
    query = docs.get(key) || graphql.parse(node, {
      noLocation: true
    });
  } else {
    key = node.__key || hashDocument(node);
    query = docs.get(key) || node;
  }
  // Add location information if it's missing
  if (!query.loc) stringifyDocument(query);
  query.__key = key;
  docs.set(key, query);
  return query;
};
var createRequest = (q, variables) => {
  if (!variables) variables = {};
  var query = keyDocument(q);
  var printedVars = stringifyVariables(variables);
  var key = query.__key;
  if (printedVars !== '{}') key = phash(printedVars, key);
  return {
    key,
    query,
    variables
  };
};
/**
 * Finds the Name value from the OperationDefinition of a Document
 */
var getOperationName = query => {
  for (var node of query.definitions) {
    if (node.kind === graphql.Kind.OPERATION_DEFINITION && node.name) {
      return node.name.value;
    }
  }
};
/**
 * Finds the operation-type
 */
var getOperationType = query => {
  for (var node of query.definitions) {
    if (node.kind === graphql.Kind.OPERATION_DEFINITION) {
      return node.operation;
    }
  }
};
var makeResult = (operation, result, response) => {
  if (!('data' in result) && !('errors' in result) || 'path' in result) {
    throw new Error('No Content');
  }
  return {
    operation,
    data: result.data,
    error: Array.isArray(result.errors) ? new CombinedError({
      graphQLErrors: result.errors,
      response
    }) : undefined,
    extensions: typeof result.extensions === 'object' && result.extensions || undefined,
    hasNext: !!result.hasNext
  };
};
var mergeResultPatch = (prevResult, patch, response) => {
  var result = {
    ...prevResult
  };
  result.hasNext = !!patch.hasNext;
  if (!('path' in patch)) {
    if ('data' in patch) result.data = patch.data;
    return result;
  }
  if (Array.isArray(patch.errors)) {
    result.error = new CombinedError({
      graphQLErrors: result.error ? [...result.error.graphQLErrors, ...patch.errors] : patch.errors,
      response
    });
  }
  var part = result.data = {
    ...result.data
  };
  var i = 0;
  var prop;
  while (i < patch.path.length) {
    prop = patch.path[i++];
    part = part[prop] = Array.isArray(part[prop]) ? [...part[prop]] : {
      ...part[prop]
    };
  }
  Object.assign(part, patch.data);
  return result;
};
var makeErrorResult = (operation, error, response) => ({
  operation,
  data: undefined,
  error: new CombinedError({
    networkError: error,
    response
  }),
  extensions: undefined
});
function makeFetchBody(request) {
  return {
    query: stringifyDocument(request.query),
    operationName: getOperationName(request.query),
    variables: request.variables || undefined,
    extensions: undefined
  };
}
var makeFetchURL = (operation, body) => {
  var useGETMethod = operation.kind === 'query' && operation.context.preferGetMethod;
  if (!useGETMethod || !body) return operation.context.url;
  var url = new URL(operation.context.url);
  var search = url.searchParams;
  if (body.operationName) search.set('operationName', body.operationName);
  if (body.query) search.set('query', body.query);
  if (body.variables) search.set('variables', stringifyVariables(body.variables));
  if (body.extensions) search.set('extensions', stringifyVariables(body.extensions));
  var finalUrl = url.toString();
  if (finalUrl.length > 2047 && useGETMethod !== 'force') {
    operation.context.preferGetMethod = false;
    return operation.context.url;
  }
  return finalUrl;
};
var makeFetchOptions = (operation, body) => {
  var useGETMethod = operation.kind === 'query' && !!operation.context.preferGetMethod;
  var headers = {
    accept: 'application/graphql+json, application/json'
  };
  if (!useGETMethod) headers['content-type'] = 'application/json';
  var extraOptions = (typeof operation.context.fetchOptions === 'function' ? operation.context.fetchOptions() : operation.context.fetchOptions) || {};
  if (extraOptions.headers) for (var key in extraOptions.headers) {
    headers[key.toLowerCase()] = extraOptions.headers[key];
  }
  return {
    ...extraOptions,
    body: !useGETMethod && body ? JSON.stringify(body) : undefined,
    method: useGETMethod ? 'GET' : 'POST',
    headers
  };
};
var decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder() : null;
var jsonHeaderRe = /content-type:[^\r\n]*application\/json/i;
var boundaryHeaderRe = /boundary="?([^=";]+)"?/i;
// NOTE: We're avoiding referencing the `Buffer` global here to prevent
// auto-polyfilling in Webpack
var toString = input => input.constructor.name === 'Buffer' ? input.toString() : decoder.decode(input);
var makeFetchSource = (operation, url, fetchOptions) => {
  var maxStatus = fetchOptions.redirect === 'manual' ? 400 : 300;
  var fetcher = operation.context.fetch;
  return wonka.make(({
    next,
    complete
  }) => {
    var abortController = typeof AbortController !== 'undefined' ? new AbortController() : null;
    if (abortController) {
      fetchOptions.signal = abortController.signal;
    }
    var hasResults = false;
    // DERIVATIVE: Copyright (c) 2021 Marais Rossouw <hi@marais.io>
    // See: https://github.com/maraisr/meros/blob/219fe95/src/browser.ts
    var executeIncrementalFetch = (onResult, operation, response) => {
      // NOTE: Guarding against fetch polyfills here
      var contentType = response.headers && response.headers.get('Content-Type') || '';
      if (/text\//i.test(contentType)) {
        return response.text().then(text => {
          onResult(makeErrorResult(operation, new Error(text), response));
        });
      } else if (!/multipart\/mixed/i.test(contentType)) {
        return response.text().then(payload => {
          onResult(makeResult(operation, JSON.parse(payload), response));
        });
      }
      var boundary = '---';
      var boundaryHeader = contentType.match(boundaryHeaderRe);
      if (boundaryHeader) boundary = '--' + boundaryHeader[1];
      var read;
      var cancel = () => {
        /*noop*/
      };
      if (response[Symbol.asyncIterator]) {
        var iterator = response[Symbol.asyncIterator]();
        read = iterator.next.bind(iterator);
      } else if ('body' in response && response.body) {
        var reader = response.body.getReader();
        cancel = () => reader.cancel();
        read = () => reader.read();
      } else {
        throw new TypeError('Streaming requests unsupported');
      }
      var buffer = '';
      var isPreamble = true;
      var nextResult = null;
      var prevResult = null;
      function next(data) {
        if (!data.done) {
          var chunk = toString(data.value);
          var boundaryIndex = chunk.indexOf(boundary);
          if (boundaryIndex > -1) {
            boundaryIndex += buffer.length;
          } else {
            boundaryIndex = buffer.indexOf(boundary);
          }
          buffer += chunk;
          while (boundaryIndex > -1) {
            var current = buffer.slice(0, boundaryIndex);
            var _next = buffer.slice(boundaryIndex + boundary.length);
            if (isPreamble) {
              isPreamble = false;
            } else {
              var headersEnd = current.indexOf('\r\n\r\n') + 4;
              var headers = current.slice(0, headersEnd);
              var body = current.slice(headersEnd, current.lastIndexOf('\r\n'));
              var payload = void 0;
              if (jsonHeaderRe.test(headers)) {
                try {
                  payload = JSON.parse(body);
                  nextResult = prevResult = prevResult ? mergeResultPatch(prevResult, payload, response) : makeResult(operation, payload, response);
                } catch (_error) {}
              }
              if (_next.slice(0, 2) === '--' || payload && !payload.hasNext) {
                if (!prevResult) return onResult(makeResult(operation, {}, response));
                break;
              }
            }
            buffer = _next;
            boundaryIndex = buffer.indexOf(boundary);
          }
        } else {
          hasResults = true;
        }
        if (nextResult) {
          onResult(nextResult);
          nextResult = null;
        }
        if (!data.done && (!prevResult || prevResult.hasNext)) {
          return read().then(next);
        }
      }
      return read().then(next).finally(cancel);
    };
    var ended = false;
    var statusNotOk = false;
    var response;
    Promise.resolve().then(() => {
      if (ended) return;
      return (fetcher || fetch)(url, fetchOptions);
    }).then(_response => {
      if (!_response) return;
      response = _response;
      statusNotOk = response.status < 200 || response.status >= maxStatus;
      return executeIncrementalFetch(next, operation, response);
    }).then(complete).catch(error => {
      if (hasResults) {
        throw error;
      }
      var result = makeErrorResult(operation, statusNotOk ? response.statusText ? new Error(response.statusText) : error : error, response);
      next(result);
      complete();
    });
    return () => {
      ended = true;
      if (abortController) {
        abortController.abort();
      }
    };
  });
};
exports.CombinedError = CombinedError;
exports.createRequest = createRequest;
exports.getOperationName = getOperationName;
exports.getOperationType = getOperationType;
exports.keyDocument = keyDocument;
exports.makeErrorResult = makeErrorResult;
exports.makeFetchBody = makeFetchBody;
exports.makeFetchOptions = makeFetchOptions;
exports.makeFetchSource = makeFetchSource;
exports.makeFetchURL = makeFetchURL;
exports.makeResult = makeResult;
exports.mergeResultPatch = mergeResultPatch;
exports.stringifyDocument = stringifyDocument;
exports.stringifyVariables = stringifyVariables;
//# sourceMappingURL=52541c06.js.map
